#  Vue.js 简介

##  为什么说Vue.js 是渐进式框架

​	 所谓渐进式框架就是把框架分层。

​	最核心部分是 视图层渲染，然后往外是组件机制，在这个基础上再加入路由机制，再加入状态管理，最外层是构建工具。

​	所谓分层，就是说你可以只用最核心的视图层渲染功能来快速开发一些需求，也可以使用一整套全家桶来开发大型应用。Vue.js有足够的灵活性来适应不同的需求，可以根据自己的需求选择不同的层级。

# 第一篇 变化侦测

​	Vue.js最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JavaScript对象。而当你修改它们的时候，视图也会进行更新。这使得状态管理非常简单，直接。

​	从状态生成DOM，再输出到用户界面显示的一整套流程叫做渲染，应用在运行时会不断地进行重新渲染。而响应式系统赋予框架重新渲染的能力，其重要组成部分是变化侦测。变化侦测是响应式系统的核心，没有它就没有重新渲染。框架在运行时，视图也就无法随着状态的变化而变化。

​	简单来说，变化侦测的作用是侦测数据的变化。当数据变化时，会通知视图进行相应的更新。

##  1 Object 的变化侦测

### 	什么是变化侦测

​		Vue.js会自动通过状态生成DOM。并将其输出到页面上显示出来，这个过程叫做**渲染**。Vue.js的渲染过程是声明式的，我们通过模板来描述状态与DOM之间的映射关系

### 	 如何追踪变化

​	使用Object.defineProperty  

​	用函数对Object.defineProperty进行封装，其作用就是定义一个响应式数据。也就是在这个函数中进行变化追踪，封装后只需要传递 data key val 就行了。 

​	封装好以后，每当从data的key中读取数据时，get函数被触发.每当往data中的key中设置数据时，set函数被触发。

###  如何收集依赖

​	如果只是把Object.defineProperty进行封装，那其实并没有什么实际用处，真正有用的是收集依赖。

 我们之所以要观察数据，其目的是当数据的属性发生变化时，可以通知那些曾经使用了该数据的地方。 在getter中收集依赖，在setter中触发依赖。

###  依赖是谁 ？

​	我们要通知用到的数据的地方，而使用这个数据的地方有很多，而且类型还不一样，既有可能是模板，也有可能是用户写的一个watch，这时需要

​	抽象出一个能集中处理这些情况的类。 然后，我们在依赖收集阶段只收集好封装好的实例进来，通知也只通知这些情况的类，接着它再负责通知其他地方。

​	它就是Watcher

### 什么是watcher

​	watcher 是一个中介的角色，数据发生变化通知它，然后它再通知其他地方。

###  递归所有的Key

​	我们希望把数据种的所有属性（包括子属性）都给侦测到，所以要封装一个Observer类，这个类的作用就是将一个数据内所有属性（包括子属性）都转换成getter/setter 的形式。然后去追踪它的变化。

​	Observer类会附加到每一个被侦测的object上。一旦被附加上，Observer会将object的所有属性都转换为getter和setter的形式

## 2 Array 的变化侦测

## 4 变化侦测相关的API实现原理

###  vm.$watch

####  用法

 用于观察一个表达式或computed 函数在Vue.js实例上的变化。回调函数调用时，会从参数得到新数据（new value）和 旧数据（old value）

####  内部原理

vm.$watch 其实是对watcher 的一种封装。

###  vm.$set

####  用法

在object上设置一个属性，如果object 是响应式的，Vue会保证属性被创建后也是响应式的，并且触发视图更新。这个方法主要用来避开Vue 不能侦测属性被添加的限制。

#  第二篇  虚拟DOM

##  1 虚拟DOM 简介

### 	 什么是虚拟DOM

​	 当代码越来越多，DOM的操作越来越频繁时，我们就会发现如果像之前那样使用，代码中会有相当多的代码是在操作DOM，程序中的状态也很难管理，代码中逻辑很混乱。

​	这其实是命令式操作DOM的问题，虽然简单易用，但是在业务越来越复杂的今天，它会有不好维护的问题。

​	我么通过描述状态和DOM之间的映射关系是怎样的，就可以将状态渲染成视图。关于状态导视图的转移过程，框架会帮我们做，不需要我们自己去手动操作DOM

​	状态可与使JavaScript中的任意类型，Object Array String Number Boolean 等都可以作为状态，这些状态可能最终会以段落，表单，链接或按钮等元素呈现在用户界面上，具体地说是呈现在页面上。

​	本质上，我们将状态作为输入，并生成DOM输出到页面上显示出来，这个过程叫做渲染。

​	然而通常程序在运行时，状态会不断发生变化（引起状态变化的原因很多，有可能是用户点击了某个按钮，也可能是某个Ajax请求，这些行为都是异步发生的，，理论上所有的异步行为都有可能引起状态变化）。每当状态发生变化，都需要重新渲染。如何确定状态中，发生了什么变化以及需要在哪里更新DOM

  虚拟DOM的解决方式是 通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染，在渲染之前，会使用新生成的虚拟节点树和上一次生成的虚拟节点树进行对比，只渲染不同的部分。

 虚拟节点树其实是由组件树建立起来的整个虚拟节点（Virtual Node 也经常被简写为vnode）

###  为什么要引入虚拟DOM

​	Vue.js 通过编译将模板转换成渲染函数（render），执行渲染函数就可以得到一个虚拟节点树，使用这个虚拟节点树就可以渲染页面。

​	虚拟DOM 的终极目标就是将虚拟节点渲染到视图上，但是如果直接使用虚拟节点覆盖旧节点的话，会有很多不必要的DOM操作。

​	为了避免不必要的DOM操作，虚拟DOM在虚拟节点映射到视图的过程中，将虚拟节点与上一次渲染视图所使用的旧虚拟节点（old vnode）做对比，找出真正需要更新的节点来进行DOM操作，从而不免操作其他无任何改动的DOM

​	对两个虚拟节点进行比对是虚拟DOM最核心的算法即（patch），它可以判断哪些节点发生了变化，从而值对发生了变化的节点进行更新操作。



  之所以需要先使用状态生成虚拟节点，是因为如果直接用状态生成真实DOM，会有一定程度上的性能浪费，而先创建虚拟节点再进行渲染视图，就可以将虚拟节点缓存，然后使用新创建的虚拟节点和上一次渲染时缓存的虚拟节点进行对比，然后根据对比结果只更新需要更新真实的DOM节点，从而避免不必要的DOM操作，节省一定的性能开销。

##   VNode

### 	 什么是VNode

​	在Vue.js中存在一个VNode类，使用它可以实例化不同类型的vnode实例，而不同的vnode实例各自表示不同类型的DOM元素

​	例如DOM元素有元素节点， 文本节点，注释节点，vnode实例也有对应的元素节点，文本节点，注释节点等。

​	vnode只是一个名字，本质上其实是JavaScript中一个普通对象，是从VNode类实例化的对象，我们从JavaScript对象来描述一个真实DOM元素后，那么该DOM元素上所有的属性在VNode 这个对象上都存在对应的属性

​	简单来说，vnode可以理解为节点描述对象，它描述了文本应该怎么去创建真实的DOM节点。

###  VNode 的作用

​	由于每次渲染视图都是先创建vnode，然后使用它创建真实DOM插入到页面中，所以可以将上一次渲染视图时所创建的vnode缓存起来。之后，每次需要重新渲染视图时，将新创建的vnode和上一次缓存的vnode进行对比，查看它们之前有哪些不一样的地方，找出这些不一样的地方并基于此去修改真实的DOM



## patch

 虚拟DOM最核心的就是patch，它可以将vnode 渲染成真实的DOM

 patch也可以叫做patching算法，通过它渲染真实的DOM时，并不是暴力的覆盖原有DOM，而是对比新旧两个vnode之间有哪些不同，然后根据对比结果找出需要更新的节点，进行更新。这点从名字可以看出，patch本身就是补丁 修补的意思，其实际作用是现有DOM上进行修改来实现更新视图的目的。

### patch 介绍

​	对比两个vnode 之间的差异知识patch的一部分，这是手段而不是目的。

1. ​	创建新增的节点
2. ​    删除已经分歧的节点
3. ​    修改需要更新的节点

# 第三篇 模板编译原理

渲染函数是创建HTML最原始的方法。模板最终会通过编译转换成渲染函数，渲染函数执行后，会得到一份vnode用于虚拟DOM渲染。所以模板编译其实是配合虚拟DOM进行渲染。

##  概念

​	平时使用模板时，可以在模板中使用一些变量来填充模板，还可以在模板中使用JavaScript表达式，又或者是使用一些指令。

​	这些功能在HTML语法中是不存在的，那么为什么在Vue.js的模板中就可以使用各种灵活的语法呢。

​	模板编译的主要目标是生成渲染函数。

## 将模板编译成渲染函数

​	分为两个步骤

  1 先将模板解析成AST（Abstract Syntax Tree）抽象语法树，然后再使用AST 生成渲染函数

 	 但是由于静态节点不需要总是渲染，所以在生成AST以后，生成的渲染函数之前这个节点，需要做一个操作，那就是遍历一遍AST，给所有的静态节点做一个标记，这样在虚拟DOM中更新节点，如果发现节点有这个标记，就不会重新渲染它。

​	大体上看模板编译分为三个部分 

  	将模板解析成AST

​	  遍历AST标记生成静态节点

​	  使用AST生成渲染函数

​	这三个部分内容在模板编译中分别抽象出三个模块来实现各自的功能，分别是

### 				解析器： 将模板解析成AST

​	

#### 	 内部原理：

​		其中最主要的就是HTML解析器，顾名思义，HTML解析器的作用就是解析HTML，它在解析HTML过程中会不断触发各种钩子函数。这些钩子函数包括开始标签钩子函数，结束标签钩子函数，文本钩子函数和注释钩子函数。

​		事实上，解析器内部也分为好几个子解析器，比如HTML解析器，文本解析器，以及过滤器解析器

​				优化器： 目标是遍历AST，检测出所有的静态子树（永远都不会发生变化的DOM节点）并给其标记。

​				代码生成器： 	它的作用是将AST转换为渲染函数中的内容，这个内容可以成为“代码字符串”

#  第四篇 整体流程

##  架构设计和目录结构

### 	架构设计

#### 核心代码

#### 		   跨平台相关

####      公用工具函数

同时其架构是分层的，最底层是一个普通的构造函数，最上层是一个入口，也就是将一个完整的构造函数导出给用户使用，在最底层和最顶层中间，我们需要逐渐添加一些方法和属性，而构造函数上一层的一些方法会最终添加到构造函数的prototype属性中，再上一层的方法最终会添加构造函数中，这些方法叫做全局API

## 实例方法和全局API的实现原理

### 	与数据相关的实例方法

vm.$watch

vm.$set

vm.$delete

### 	事件相关的方法

#### vm.$on

​		监听当前实例的自定义事件，事件可以由vm.$emit触发。 回调函数会接收所有传入事件所触发的的函数的额外参数

#### vm.$once

​	监听一个自定义事件，但是只触发以此，在第一次触发之后移除监听器

#### vm.$off

​	移除自定义事件监听器 

- 如果没有提供参数，则移除所有事件的监听器
- 如果只提供了事件，则移除该事件的所有监听器
- 如果同时提供了事件和回调，则只移除这个回调的监听器

#### vm.$emit

​	触发当前实例上的事件，附加参数会传给监听器回调。

###  生命周期相关的实例方法

​    与生命周期相关的实例方法有四个 

#### vm.$mount

​	我们并不常用这个方法，其原因是如果在实例化Vue.js 设置了el选项，会自动把Vue.js 实例挂载到DOM元素上。

##### 用法 

​		如果Vue实例在实例化上没有收到el选项，则它处于未挂载的状态。没有关联DOM元素。我们可以使用vm.$mount手动挂载一个未挂载的

实例。

#### vm.$forceUpdate

​	作用是迫使Vue.js实例重新渲染，它仅仅实例本身以及插入插槽内容的子组件，而不是所有子组件。

我们只需要执行实例中的watcher的update 方法，就可以让实例重新渲染，

#### vm.$destory

完全销毁一个实例，它会清理该实例与其他实例的连接，并解绑其全部指令以及监听器。同时会触发beforeDestory和destoryed的钩子函数

​	这个方法不常用，大部分场景不需要销毁组件，只需要使用v-if 或v-show 等指令以数据驱动的方式控制子组件的生命周期即可。

#### vm.$nextTick

​	nextTick接收一个回调函数作为参数，它的作用是将回调延迟到下次DOM更新周期之后执行。它与全局方法Vue.nextTick一样，不同的是回调的this自动绑定到调用它的实例上。

  我们在开发项目中会遇到一个场景

​		当更新了状态（数据）后，需要对新DOM做一些操作。但是这时我们其实获取不到更新后的DOM，因为还没有重新渲染。这个时候我们需要使用nextTick方法

###  事件循环

​	我们都知道JavaScript是一门单线程且非阻塞的脚本语言，这意味着JavaScript代码在执行时的任何时候都只有一个主线程来处理所有任务。而非阻塞是指当代码需要处理异步任务时，主线程会挂起（pending）这个任务，当异步任务处理完毕后，主线程再根据一定规则去执行相应的回调。

​	事实上，当任务处理完毕后，JavaScript会将这个事件假如一个队列中，我们将这个队列称为事件队列。被放入事件队列的事件不会立即执行它的回调，而是等待当前执行栈中所有任务执行完毕后，主线程会去查找任务队列中是否有任务。

​	异步任务分为两个类型  

##### 微任务（microtask）

- Promise.then
- MutationObserver
- Object.observer
- process.nextTick

##### 宏任务（macrotask）

- setTimeout
- setInterval
- setImmediate
- I/O
- UI交互事件

  当执行栈中所有的任务都执行完毕后，会去检查微任务队列中是否有事件存在，如果存在，依次执行微任务队列中事件对应的回调，直到为空。然后去宏任务队列取出一个事件，把它对应的回调放入当前执行栈，当执行栈中所有的任务都执行完毕后，检查微任务队列 中是否有事件存在。无限重复此过程，形成一个无限循环。

###  什么是执行栈

​	当我们执行一个方法时，JavaScript会生成一个与这个方法对应的执行环境（content）又叫做执行上下文。这个执行环境又有这个方法的私有作用域，上层作用域的执行，方法的参数，私有作用域中定义的变量以及this对象。这个执行环境会被添加到一个栈中，这个栈就是执行栈。

​	如果在这个方法的代码中执行到了一行函数调用语句，那么JavaScript会生成这个函数的执行环境并将其添加到执行栈中，然后进入这个执行环境继续执行其中的代码。执行完毕后并返回结果，JavaScript会退出执行环境并把这个执行环境从栈中给销毁，回到上一个方法的执行环境。这个过程反复进行，知道执行栈中的代码全部执行完毕。这个执行环境就是执行栈。

 下次DOM更新周期，其实就是下次微任务执行时更新DOM。

 由于vm.$nextTick会将回调添加到任务队列中延迟执行，所以在回调执行前，如果反复调用

vm.$nextTick ，Vue.js 并不会反复将回调添加到任务队列中，只会向任务队列中添加一个任务。

###  全局API 实现的原理

​	Vue.extend  

​	 使用Vue构造器创建一个子类，其参数是一个包含组件选项的对象。

 	

#### Vue.filter

##### 参数  

​	｛string｝ id

​       ｛Function| Object｝ [definition]

##### 用法

​	注册或获取全局过滤器

   用在两个地方 双花括号插值和v-bind 表达式 过滤器应该被添加到JavaScript表达式的尾部

####  Vue.component

##### 用法

​	注册或获取全局组件，注册组件时，还会自动使用给定的id设置组件的名称

#### Vue.use

 安装Vue.js插件。

#### Vue.mixin

#####  用法

全局注册一个混入（mixin）

## 生命周期

​	每个Vue.js实例在创建阶段时都要经过一系列的初始化，例如设置数据监听，编译模板，将实例挂载到DOM并在数据变化时更新DOM等，同时，也会运行一些叫做生命周期钩子的函数，这给了我们在不同阶段添加自定义代码的机会。



###  初始化阶段

​	从new Vue()dao created之间的阶段叫做初始化阶段

​	  这个阶段主要的目的是在Vue 实例上初始化一些属性，事件以及响应式数据，如props，methods，data，computed，watch等

### 模板编译阶段

​	created钩子函数与beforeMount钩子函数之间的阶段

​	主要将模板编译为渲染函数。

### 挂载阶段

​	beforeMount到mounted 

​	 通俗来说 就是将模板渲染到指定的DOM元素上，在挂载的过程中Vue.js会开启watcher 来持续追踪依赖的变化。

### 卸载阶段

 应用调用vm.$destory方法后，Vue.js是生命周期也进入了卸载阶段

 Vue.js 会将自身从父组件中删除，取消实例中所有依赖的追踪并且移除所有事件的监听器。

###  new Vue（） 被调用时，发生了什么 ？

### 初始化实例属性

 以$开头的属性是提供给用户使用的外部属性 ，

以 _   开头的属性是提供给内部使用的属性。

### 初始化事件

​	初始化事件就是将父组件在模板中使用的v-on 注册的时间添加到子组件的事件系统中。

​	父组件的模板中使用v-on来监听子组件中触发的事件，并在子组件中使用this.$emit来触发该事件。

###  初始化状态

  当我们在开发应用时，经常会用到一些状态，例如props methods  data computed 和watch 

 在Vue.js内部，这些状态在使用之前需要进行初始化。 

 初始化的顺序是精心设计安排的，先初始化props，后初始化data，这样子就可在data中使用props中的数据了，watch中既可以观察props，

又可以观察data 因为它是最后被初始化的。

####  初始化props

​	子组件被实例化时，会先对props进行格式化处理，规格化之后的props为对象格式。

#### 初始化computed

​	简单来说computed是定义在vm上的一个特殊的getter方法，之所以特殊，是因为在vm实例上定义getter方法，get并不是用户提供的函数，而是Vue.js内部的一个代理函数。在代理函数中可以结合watcher实现缓存与收集依赖等功能。

​	计算属性一个特点是由缓存，计算属性函数所依赖的数据在没有发生变化的情况下，会反复读取计算属性，而计算属性的函数并不会反腐之星。

##  指令

